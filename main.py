from ODE_Problem import Problem
from SLV_Prob import Solver


def ode_sol_prob():
    """
    Функция формирования начальной задачи Коши Problem и запуска методов решателя Solver.

    Параметры и порядок запуска:

    problem = Problem(вектор начальных условий, интервал интегрирования ОДУ)
    Класс Problem формирует начальную задачу Коши и возвращает вектор-функцию ОДУ

    solver = Solver(problem, шаг интегрирования, тип численной схемы решателя)
    Класс Solver непосредственно необходим для решения задачи Коши, а также
    вывода графиков решения, значений оценки погрешностей, графика погрешности
    вычислений и оценки эффективности метода в зависимости от выбранного шага.

    Реализованы селдующие 4 типа численной схемы решателя:
    # 1. Прямой метод Эйлера 2 порядка точности FE (solver_type = 1)
    # 2. Метод Рунге-Кутта 4 порядка (явная схема) RK4 (solver_type = 2)
    # 3. Метод Адамса-Башфорта-Моултона 4 порядка ABM4 (solver_type = 3)
    # 4. Метод Милнса 4 порядка точности  MLN (solver_type = 4)

    Класс решателя имеет несколько функций (методов):

    1) solver.dsolve() - численное решение заданной классом Problem задачи Коши для ОДУ
    ДАННЫЙ МЕТОД ДОЛЖЕН БЫТЬ ВЫЗВАН В САМОМ НАЧАЛЕ, С ЦЕЛЬЮ ПОЛУЧЕНИЯ ЗНАЧЕНИЙ РЕШЕНИЯ И
    ВЫЗОВА ДРУГИХ МЕТОДОВ КЛАССА, ЕСЛИ НЕОБХОДИМО!!!

    2) solver.table_dsol() - вывод значений точек "x", узлов в которых отыскивается решение,
    а также значений численного решения, значения аналитичекого точного решения, значения
    погрешности вычислений в виде таблицы. Возвращает также максимальное значение погрешности вычислений.

    3) solver.plot_sol() - вывод графика результатов численного моделирования и точного решения
    дял валидации расчетов. Точное аналитическое решение и график функции y(x), являющейся решением
    исходной задачи Коши представлены отдельно в файле Analytic_Solve.ipynb.

    4) solver.plot_accuracy() - вывод графика погрешности вычислений.

    5) solver.norm_accuracy() - функция оценки нормы погрешности расчета.

    6) solver.err_sch() - возвращает значение оценки погрешности дискретизации.
    Данная оценка является оценкой верхней грани, приблизительно для не адаптивных
    численных разностных схем решения задачи Коши имеет вид: E(dx) = O(dx^n), где
    n - порядок схемы решателя. Для схемы Милнса полагают n = 3, хотя данная схема
    является схемой 4 порядка точности.

    7) solver.accuracy_approx(dxx) - вывод графика динамики нормы погрешности расчета
    в зависиомсти от типа выбранной схемы и шага интегрирования. Позволяет опрделеить,
    какой шаг решателся рекомендуется выбирать. Если значение нормы превышает 1,
    то данный шаг интегрирования выбирать не рекомендуется.


    ПРИМЕЧАНИЕ: Поскольку реализованы не адаптивные схемы, то контроль точности шага в данном
    случае не предусмотрен. Реализация адаптивных схем несколько сложна, однако ее применение
    в данной задаче нецелесообразно. Данное ОДУ не является жестким или задача не представляет
    собой задачу Неймана (требуется как наличие начальных так и граничных условий).
    """

    problem = Problem(u0=[0, 3, -9, -8, 0], End=5)
    solver = Solver(problem, dx=0.05, solver_type=1)
    solver.dsolve()
    solver.table_dsol()
    solver.plot_sol()
    solver.plot_accuracy()
    solver.norm_accuracy()
    solver.err_sch()

    # Если необходимо исследовать эффективность схемы в зависимости от выбранного шага интегрирования.
    # Раскомментировать, если необходимо 72 - 75 строки.
    # dxx = [0.005, 0.01, 0.015, 0.02, 0.025, 0.05, 0.075, 0.1, 0.15, 0.2, 0.25]
    # problem1 = Problem(u0=[0, 3, -9, -8, 0], End=5)
    # solver1 = Solver(problem1, dxx, solver_type=4)
    # solver1.accuracy_approx(dxx)


if __name__ == '__main__':
    ode_sol_prob()